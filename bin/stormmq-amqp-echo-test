#!/usr/bin/env ruby
#
# Copyright (c) 2010 StormMQ Limited
#
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 (the "License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.mozilla.org/MPL/
#

$:.unshift File.dirname(__FILE__) + '/../lib'
require 'rubygems'
require 'optparse'
require 'stormmq-client'

def required_options
  [:user, :password, :company, :system, :environment]
end

def main
  options = parse_command_line_options()
  EM.run do

    connection = StormMQ.connect(
      :user        => options[:user],
      :pass        => options[:password],
      :company     => options[:company],
      :system      => options[:system],
      :environment => options[:environment],
      :logging     => options[:trace]
    )

    # open a channel on the A MQP connection
    channel = MQ.new(connection)

    # declare a queue on the channel
    queue = MQ::Queue.new(channel, 'queue name')

    # create a fanout exchange
    exchange = MQ::Exchange.new(channel, :fanout, 'all queues')

    # bind the queue to the exchange
    queue.bind(exchange)

    # publish a message to the exchange
    exchange.publish('hello world')

    # subscribe to messages in the queue
    queue.subscribe do |headers, msg|
      puts msg == 'hello world' ? 'Succeeded' : 'Failed'
      connection.close{ EM.stop_event_loop }
    end

  end

end

def parse_command_line_options

  options = {}

  optparse = OptionParser.new do|opts|
     # Set a banner, displayed at the top
     # of the help screen.
     opts.banner = "Usage: #{$0} [options]"

     # This displays the help screen, all programs are
     # assumed to have this option.
     opts.on( '-h', '--help', 'display this screen' ) do
       puts opts
       exit
     end

     opts.on( '-u', '--amqp_user USER', 'USER is your login at http://stormmq.com/' ) do |user|
       options[:user] = user
     end

     opts.on( '-p', '--amqp_password PASSWORD', 'eg BNuWk1agaAUPTZ15sx44kHvNkTnJXsevqTjIo1M1iwFOeNaUqr3qPn75Dnk==' ) do |password|
       options[:password] = password
     end

     opts.on( '-c', '--company COMPANY', 'your company, usually the same as your user name' ) do |company|
       options[:company] = company
     end

     opts.on( '-e', '--environment ENVIRONMENT', 'development, testing, production for the system we initially created') do |environment|
       options[:environment] = environment
     end

     opts.on( '-s', '--system SYSTEM', 'your system, the same as your user name for the system we initially created') do |system|
       options[:system] = system
     end

     opts.on( '-t', '--trace', 'output the dialogue between client and server') do
       options[:trace] = true
     end

   end

  begin
    optparse.parse!
  rescue OptionParser::ParseError => e
    puts e
    exit
  end

  required_options = required_options()
  required_options.each do |option|
    unless options.has_key? option
      puts "#{option.to_s.upcase} is missing but is required!"
      exit
    end
  end

  options

end

main

__END__
